import { useCallback, useState, useEffect, useRef } from 'react';

function useWindowSize() {
  var validWindow = typeof window === 'object';
  var getSize = useCallback(function () {
    var size = {
      width: validWindow ? window.innerWidth : undefined,
      height: validWindow ? window.innerHeight : undefined
    };
    return size;
  }, [validWindow]);

  var _useState = useState(getSize()),
      size = _useState[0],
      setSize = _useState[1];

  useEffect(function () {
    function handleResize() {
      setSize(getSize());
    }

    if (validWindow) {
      window.addEventListener('resize', handleResize);
      return function () {
        window.removeEventListener('resize', handleResize);
      };
    }
  }, [getSize, validWindow]);
  return size;
}

function useInterval(callback, delay) {
  var savedCallback = useRef(null);
  useEffect(function () {
    savedCallback.current = callback;
  }, [callback]);
  useEffect(function () {
    function tick() {
      var _savedCallback$curren;

      (_savedCallback$curren = savedCallback.current) === null || _savedCallback$curren === void 0 ? void 0 : _savedCallback$curren.call(savedCallback);
    }

    if (delay) {
      var id = setInterval(function () {
        tick();
      }, delay);
      return function () {
        clearInterval(id);
      };
    }
  }, [delay]);
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isNullOrUndefined(value) {
  return [null, undefined].includes(value);
}

var WINDOW = 'window';
var PARENT = 'parent';

function getElementSizes(element) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var parentRect = element.getBoundingClientRect();
  var top = parentRect.top,
      bottom = parentRect.bottom,
      left = parentRect.left,
      right = parentRect.right;
  return {
    top: top,
    bottom: bottom,
    left: left,
    right: right
  };
}

function isElementInView(element, windowHeight, windowWidth) {
  if (element) {
    var _getElementSizes = getElementSizes(element),
        left = _getElementSizes.left,
        right = _getElementSizes.right,
        top = _getElementSizes.top,
        bottom = _getElementSizes.bottom;

    if (left > windowWidth) {
      return false;
    } else if (right < 0) {
      return false;
    } else if (top > windowHeight) {
      return false;
    } else if (bottom < 0) {
      return false;
    }
  }

  return true;
}

function useInfiniteScroll(_ref) {
  var loading = _ref.loading,
      hasNextPage = _ref.hasNextPage,
      onLoadMore = _ref.onLoadMore,
      _ref$threshold = _ref.threshold,
      threshold = _ref$threshold === void 0 ? 150 : _ref$threshold,
      _ref$checkInterval = _ref.checkInterval,
      checkInterval = _ref$checkInterval === void 0 ? 200 : _ref$checkInterval,
      _ref$scrollContainer = _ref.scrollContainer,
      scrollContainer = _ref$scrollContainer === void 0 ? WINDOW : _ref$scrollContainer;
  var ref = useRef(null);

  var _useWindowSize = useWindowSize(),
      windowHeight = _useWindowSize.height,
      windowWidth = _useWindowSize.width; // Normally we could use the "loading" prop, but when you set "checkInterval" to a very small
  // number (like 10 etc.), some request components can't set its loading state
  // immediately (I had this problem with react-apollo's Query component. In some cases, it runs
  // "updateQuery" twice). Thus we set our own "listen" state which immeadiately turns to "false" on
  // calling "onLoadMore".


  var _useState = useState(true),
      listen = _useState[0],
      setListen = _useState[1];

  useEffect(function () {
    if (!loading) {
      setListen(true);
    }
  }, [loading]);

  function getBottomOffset() {
    var element = ref.current;

    if (!element || isNullOrUndefined(windowHeight)) {
      return null;
    }

    var rect = element.getBoundingClientRect();
    var bottom = rect.bottom;
    var bottomOffset = bottom - windowHeight;

    if (scrollContainer === PARENT) {
      var parent = element.parentNode;

      if (!parent) {
        return null;
      }

      var _getElementSizes2 = getElementSizes(parent),
          parentBottom = _getElementSizes2.bottom; // Distance between bottom of list and its parent


      bottomOffset = bottom - parentBottom;
    }

    return bottomOffset;
  }

  function isParentInView() {
    var _ref$current;

    var parent = (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.parentNode;

    if (!parent || isNullOrUndefined(windowHeight) || isNullOrUndefined(windowWidth)) {
      return false;
    }

    return isElementInView(parent, windowHeight, windowWidth);
  }

  function isListInView() {
    var element = ref.current;

    if (!element || isNullOrUndefined(windowHeight) || isNullOrUndefined(windowWidth)) {
      return false;
    }

    return isElementInView(element, windowHeight, windowWidth);
  }

  function listenBottomOffset() {
    if (listen && !loading && hasNextPage) {
      if (ref.current) {
        if (scrollContainer === PARENT) {
          if (!isParentInView()) {
            // Do nothing if the parent is out of screen
            return;
          }
        } else if (!isListInView()) {
          return;
        } // Check if the distance between bottom of the container and bottom of the window or parent
        // is less than "threshold"


        var bottomOffset = getBottomOffset();

        if (isNullOrUndefined(bottomOffset)) {
          return;
        }

        var validOffset = bottomOffset < threshold;

        if (validOffset) {
          setListen(false);
          onLoadMore();
        }
      }
    }
  }

  useInterval(function () {
    listenBottomOffset();
  }, // Stop interval when there is no next page.
  hasNextPage ? checkInterval : 0);
  return ref;
}

export default useInfiniteScroll;
//# sourceMappingURL=react-infinite-scroll-hook.esm.js.map
